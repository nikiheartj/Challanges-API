import { BufferResultFile } from "@allurereport/reader-api";
import * as console from "node:console";
import { randomUUID } from "node:crypto";
import { ensureArray, ensureInt, ensureString, isArray, isNonNullObject, isString } from "../utils.js";
import { STEP_NAME_PLACEHOLDER, TEST_NAME_PLACEHOLDER } from "./model.js";
const NS_IN_MS = 1000000;
const readerId = "cucumberjson";
const allureStepStatusPriorityOrder = {
    failed: 0,
    broken: 1,
    unknown: 2,
    skipped: 3,
    passed: 4,
};
const cucumberStatusToAllureStatus = {
    unknown: "unknown",
    passed: "passed",
    skipped: "skipped",
    pending: "skipped",
    ["undefined"]: "broken",
    ambiguous: "broken",
    failed: "failed",
};
const allureStepMessages = {
    unknown: "The result of the step is unknown",
    passed: "The step passed",
    skipped: "The step was skipped because the previous step hadn't passed",
    pending: "The step signalled pending during execution",
    ["undefined"]: "The step didn't match any definition",
    ambiguous: "The step matched more than one definition",
    failed: "The step failed",
};
export const cucumberjson = {
    read: async (visitor, data) => {
        const originalFileName = data.getOriginalFileName();
        if (originalFileName.endsWith(".json")) {
            try {
                const parsed = await data.asJson();
                if (parsed) {
                    let oneOrMoreFeaturesParsed = false;
                    for (const feature of parsed) {
                        oneOrMoreFeaturesParsed || (oneOrMoreFeaturesParsed = await processFeature(visitor, originalFileName, feature));
                    }
                    return oneOrMoreFeaturesParsed;
                }
            }
            catch (e) {
                console.error("error parsing", originalFileName, e);
                return false;
            }
        }
        return false;
    },
    readerId: () => readerId,
};
const processFeature = async (visitor, originalFileName, feature) => {
    if (isCucumberFeature(feature)) {
        const preProcessedFeature = preProcessFeature(feature);
        for (const scenario of feature.elements) {
            await processScenario(visitor, originalFileName, preProcessedFeature, scenario);
        }
        return true;
    }
    return false;
};
const processScenario = async (visitor, originalFileName, feature, scenario) => {
    const preProcessedScenario = preProcessScenario(scenario);
    if (shouldProcessScenario(preProcessedScenario)) {
        const preProcessedSteps = await preProcessSteps(visitor, scenario.steps ?? []);
        await visitor.visitTestResult(mapCucumberScenarioToAllureTestResult(feature, preProcessedScenario, preProcessedSteps), {
            readerId,
            metadata: { originalFileName },
        });
    }
};
const shouldProcessScenario = ({ type }) => type !== "background";
const preProcessSteps = async (visitor, steps) => {
    const preProcessedSteps = [];
    for (const step of steps) {
        preProcessedSteps.push(await preProcessOneStep(visitor, step));
    }
    return preProcessedSteps;
};
const preProcessOneStep = async (visitor, step) => {
    const { keyword, name, result } = step;
    const { status, duration, error_message: errorMessage } = result ?? {};
    return {
        name: ensureString(name)?.trim(),
        keyword: ensureString(keyword)?.trim(),
        status: status ?? "unknown",
        duration: ensureInt(duration),
        errorMessage,
        attachments: await processStepAttachments(visitor, step),
    };
};
const processStepAttachments = async (visitor, step) => [
    await processStepDocStringAttachment(visitor, step.doc_string),
    await processStepDataTableAttachment(visitor, step.rows),
    ...(await processCucumberJsStepArguments(visitor, step.arguments)),
    ...(await processStepEmbeddingAttachments(visitor, step)),
].filter((s) => typeof s !== "undefined");
const processStepDocStringAttachment = async (visitor, docString) => {
    if (docString) {
        const { value, content, content_type: contentType } = docString;
        const resolvedValue = ensureString(value ?? content);
        if (resolvedValue && resolvedValue.trim()) {
            return await visitBufferAttachment(visitor, "Description", Buffer.from(resolvedValue), ensureString(contentType) || "text/markdown");
        }
    }
};
const processStepDataTableAttachment = async (visitor, rows) => {
    if (isArray(rows)) {
        const content = formatDataTable(rows);
        return await visitBufferAttachment(visitor, "Data", Buffer.from(content), "text/csv");
    }
};
const processCucumberJsStepArguments = async (visitor, stepArguments) => {
    const attachments = [];
    if (isArray(stepArguments)) {
        for (const stepArgument of stepArguments) {
            if (isNonNullObject(stepArgument)) {
                if ("content" in stepArgument) {
                    attachments.push(await processStepDocStringAttachment(visitor, stepArgument));
                }
                else if ("rows" in stepArgument) {
                    attachments.push(await processStepDataTableAttachment(visitor, stepArgument.rows));
                }
            }
        }
    }
    return attachments;
};
const processStepEmbeddingAttachments = async (visitor, { embeddings }) => {
    const attachments = [];
    const checkedEmbeddings = ensureArray(embeddings) ?? [];
    const getName = checkedEmbeddings.length > 1 ? (i) => `Embedding ${i}` : () => "Embedding";
    const embeddingsWithNames = checkedEmbeddings.map((e, i) => [e, getName(i + 1)]);
    for (const [embedding, fallbackName] of embeddingsWithNames) {
        if (isNonNullObject(embedding)) {
            attachments.push(await visitBufferAttachment(visitor, ensureString(embedding.name, fallbackName), Buffer.from(ensureString(embedding.data, ""), "base64"), ensureString(embedding.mime_type, "application/octet-stream")));
        }
    }
    return attachments;
};
const visitBufferAttachment = async (visitor, name, content, contentType) => {
    const fileName = randomUUID();
    await visitor.visitAttachmentFile(new BufferResultFile(content, fileName), { readerId });
    return {
        type: "attachment",
        contentType,
        originalFileName: fileName,
        name,
    };
};
const formatDataTable = (rows) => {
    return rows
        .filter((isNonNullObject))
        .map(formatDataTableRow)
        .filter(isString)
        .join("\r\n");
};
const formatDataTableRow = ({ cells }) => {
    const checkedCells = ensureArray(cells);
    return checkedCells ? checkedCells.map(formatDataTableCell).join(",") : undefined;
};
const formatDataTableCell = (cell) => {
    const escapedCell = ensureString(cell, "").replaceAll(String.raw `"`, String.raw `""`);
    return `"${escapedCell}"`;
};
const isCucumberFeature = ({ keyword, elements }) => typeof keyword === "string" && keyword.toLowerCase() === "feature" && Array.isArray(elements);
const pairWithAllureSteps = (preProcessedCucumberSteps) => preProcessedCucumberSteps.map((c) => {
    return {
        preProcessedStep: c,
        allureStep: createAllureStepResult(c),
    };
});
const mapCucumberScenarioToAllureTestResult = (preProcessedFeature, scenario, preProcessedSteps) => {
    const postProcessedSteps = pairWithAllureSteps(preProcessedSteps);
    return {
        fullName: calculateFullName(preProcessedFeature, scenario),
        name: scenario.name ?? TEST_NAME_PLACEHOLDER,
        description: scenario.description,
        duration: convertDuration(calculateTestDuration(postProcessedSteps)),
        steps: postProcessedSteps.map(({ allureStep }) => allureStep),
        labels: calculateTestLabels(preProcessedFeature, scenario),
        ...resolveTestResultStatusProps(postProcessedSteps),
    };
};
const calculateTestLabels = ({ name: featureName, tags: featureTags }, { tags: scenarioTags }) => {
    const labels = [];
    if (featureName) {
        labels.push({ name: "feature", value: featureName });
    }
    labels.push(...featureTags.map((value) => ({ name: "tag", value })), ...scenarioTags.map((value) => ({ name: "tag", value })));
    return labels;
};
const preProcessFeature = (feature) => {
    return {
        id: ensureString(feature.id),
        name: ensureString(feature.name),
        uri: ensureString(feature.uri),
        tags: parseTags(feature.tags),
    };
};
const parseTags = (tags) => {
    return (ensureArray(tags) ?? [])
        .filter((isNonNullObject))
        .map(({ name }) => name)
        .filter(isString);
};
const preProcessScenario = (scenario) => {
    return {
        id: ensureString(scenario.id),
        name: ensureString(scenario.name),
        description: ensureString(scenario.description),
        tags: parseTags(scenario.tags),
        type: scenario.type,
    };
};
const calculateFullName = ({ uri: featureUri, name: featureName, id: featureId }, { name: scenarioName, id: scenarioId }) => {
    if (!scenarioName && !scenarioId) {
        return randomUUID();
    }
    const featurePart = featureUri || featureName || featureId;
    if (featurePart) {
        const scenarioPart = scenarioName || scenarioId;
        return `${featurePart}#${scenarioPart}`;
    }
    return scenarioId || scenarioName;
};
const calculateTestDuration = (cucumberAllureStepData) => cucumberAllureStepData.reduce((testDuration, { preProcessedStep: { duration } }) => typeof testDuration === "undefined" ? duration : testDuration + (duration ?? 0), undefined);
const resolveTestResultStatusProps = (cucumberAllureSteps) => {
    const stepsData = getCucumberAllureStepWithMaxPriorityStatus(cucumberAllureSteps);
    return stepsData
        ? resolveResultOfTestFromStepsData(stepsData)
        : {
            status: "unknown",
            message: "Step results are missing",
        };
};
const resolveResultOfTestFromStepsData = ({ preProcessedStep: { status: cucumberStatus, errorMessage }, allureStep: { name, status }, }) => ({
    status: status ?? "unknown",
    ...resolveTestMessageAndTrace(name, cucumberStatus, errorMessage),
});
const resolveTestMessageAndTrace = (allureStepName, status, errorMessage) => status !== "passed"
    ? {
        message: resolveTestMessage(status, allureStepName),
        trace: errorMessage,
    }
    : {};
const resolveTestMessage = (cucumberStepStatus, allureStepName) => {
    switch (cucumberStepStatus) {
        case "failed":
            return `The step '${allureStepName}' failed`;
        case "skipped":
            return "One or more steps of the scenario were skipped";
        case "pending":
            return `The step '${allureStepName}' signalled pending during execution`;
        case "undefined":
            return `The step '${allureStepName}' didn't match any definition`;
        case "ambiguous":
            return `The step '${allureStepName}' matched more than one definition`;
        case "unknown":
        default:
            return `The result of the step '${allureStepName}' is unknown`;
    }
};
const getCucumberAllureStepWithMaxPriorityStatus = (cucumberAllureSteps) => {
    switch (cucumberAllureSteps.length) {
        case 0:
            return undefined;
        case 1:
            return cucumberAllureSteps[0];
        default:
            return cucumberAllureSteps.reduce(statusPriorityReducingFn);
    }
};
const statusPriorityReducingFn = (testDefiningStep, currentStep) => allureStepStatusPriorityOrder[testDefiningStep.allureStep.status] <=
    allureStepStatusPriorityOrder[currentStep.allureStep.status]
    ? testDefiningStep
    : currentStep;
const createAllureStepResult = ({ keyword, name, status, duration, errorMessage, attachments, }) => ({
    type: "step",
    name: getAllureStepName(keyword, name),
    steps: attachments,
    ...mapCucumberStepResultToStepProps(status, duration, errorMessage),
});
const getAllureStepName = (keyword, name) => {
    if (!name) {
        return keyword ? `${keyword} <${STEP_NAME_PLACEHOLDER.toLowerCase()}>` : STEP_NAME_PLACEHOLDER;
    }
    return keyword ? `${keyword} ${name}` : name;
};
const mapCucumberStepResultToStepProps = (status, duration, errorMessage) => ({
    status: cucumberStatusToAllureStatus[status ?? "unknown"] ?? "unknown",
    duration: convertDuration(duration),
    ...resolveStepMessageAndTrace(status, errorMessage),
});
const resolveStepMessageAndTrace = (status, errorMessage) => status !== "passed" || errorMessage
    ? {
        message: allureStepMessages[status ?? "unknown"] ?? allureStepMessages.unknown,
        trace: errorMessage,
    }
    : {};
const convertDuration = (duration) => typeof duration !== "undefined" ? nsToMs(duration) : undefined;
const nsToMs = (ns) => Math.round(ns / NS_IN_MS);
