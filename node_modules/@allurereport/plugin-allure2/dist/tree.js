import { byStatistic, compareBy } from "@allurereport/core-api";
import { createHash } from "node:crypto";
import { calculateStatisticByLeafs } from "./utils.js";
const rootNodeUid = "__ROOT__";
const createLeaf = (endNode, test) => {
    const leaf = {
        parentUid: endNode.uid,
        uid: test.uid,
        name: test.name,
        status: test.status,
        time: { ...test.time },
        flaky: test.flaky,
        newFailed: test.newFailed,
        newBroken: test.newBroken,
        newPassed: test.newPassed,
        retriesCount: test.retriesCount,
        retriesStatusChange: test.retriesStatusChange,
        parameters: test.parameters.filter((p) => p.value).map((p) => p.value),
        tags: test.extra.tags ?? [],
    };
    return leaf;
};
export const byLabels = (labelNames) => {
    return (test) => groupByLabels(test, labelNames);
};
export const createTree = (tests, classifier, leafFactory = createLeaf) => {
    const groups = new Map();
    const root = { uid: rootNodeUid, name: rootNodeUid, children: [] };
    groups.set(root.uid, root);
    for (const test of tests) {
        const treeLayers = classifier(test);
        if (!treeLayers) {
            continue;
        }
        getEndNodes(test, root, treeLayers, 0, groups).forEach((endNode) => {
            const leaf = leafFactory(endNode, test);
            endNode.children.push(leaf);
        });
    }
    return root;
};
const getEndNodes = (item, node, classifiers, index, groups) => {
    if (index >= classifiers.length) {
        return [node];
    }
    const layer = classifiers[index];
    return layer.groups.flatMap((name) => {
        const uid = groupUid(node.uid, name);
        if (!groups.has(uid)) {
            const value = { uid, name, children: [] };
            groups.set(uid, value);
            node.children.push(value);
        }
        const treeGroup = groups.get(uid);
        return getEndNodes(item, treeGroup, classifiers, index + 1, groups);
    });
};
const groupByLabels = (test, labelNames) => {
    const result = [];
    for (const name of labelNames) {
        const groups = test.labels
            .filter((label) => label.name === name)
            .filter((label) => !!label.value)
            .map((label) => label.value);
        if (groups.length !== 0) {
            result.push({ groups: Array.from(new Set(groups)) });
        }
    }
    return result;
};
const groupUid = (parentUid, groupName) => {
    return md5(parentUid ? `${parentUid}.${groupName}` : groupName);
};
const md5 = (data) => createHash("md5").update(data).digest("hex");
export const collapseTree = (treeGroup, separator = ".") => {
    const newChildren = treeGroup.children.map((c) => {
        if (!("children" in c)) {
            return c;
        }
        let res = c;
        while (res.children.length === 1 && "children" in res.children[0]) {
            const child = res.children[0];
            res = {
                uid: groupUid(res.uid, child.uid),
                name: res.name + separator + child.name,
                children: child.children,
            };
        }
        return res;
    });
    treeGroup.children = newChildren;
    return treeGroup;
};
export const createWidget = (root) => {
    const items = root.children
        .map((c) => {
        if (!("children" in c)) {
            return undefined;
        }
        const res = c;
        const statistic = calculateStatisticByLeafs(res);
        return { uid: res.uid, name: res.name, statistic };
    })
        .filter((value) => value)
        .map((value) => value)
        .sort(compareBy("statistic", byStatistic()))
        .slice(0, 10);
    return {
        items,
        total: root.children.length,
    };
};
