var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Events_instances, _Events_emitter, _Events_handlers, _Events_createHandler;
import console from "node:console";
import { setTimeout } from "node:timers/promises";
export class Events {
    constructor(emitter) {
        _Events_instances.add(this);
        _Events_emitter.set(this, void 0);
        _Events_handlers.set(this, []);
        this.onTestResults = (listener, options = {}) => {
            const { maxTimeout = 100 } = options;
            const handler = __classPrivateFieldGet(this, _Events_instances, "m", _Events_createHandler).call(this, maxTimeout, listener);
            __classPrivateFieldGet(this, _Events_emitter, "f").on("testResult", handler);
        };
        this.onTestFixtureResults = (listener, options = {}) => {
            const { maxTimeout = 100 } = options;
            const handler = __classPrivateFieldGet(this, _Events_instances, "m", _Events_createHandler).call(this, maxTimeout, listener);
            __classPrivateFieldGet(this, _Events_emitter, "f").on("testFixtureResult", handler);
        };
        __classPrivateFieldSet(this, _Events_emitter, emitter, "f");
    }
    onAttachmentFiles(listener, options = {}) {
        const { maxTimeout = 100 } = options;
        const handler = __classPrivateFieldGet(this, _Events_instances, "m", _Events_createHandler).call(this, maxTimeout, listener);
        __classPrivateFieldGet(this, _Events_emitter, "f").on("attachmentFile", handler);
    }
    onAll(listener, options = {}) {
        const { maxTimeout = 100 } = options;
        const handler = __classPrivateFieldGet(this, _Events_instances, "m", _Events_createHandler).call(this, maxTimeout, listener);
        __classPrivateFieldGet(this, _Events_emitter, "f").on("testResult", handler);
        __classPrivateFieldGet(this, _Events_emitter, "f").on("testFixtureResult", handler);
        __classPrivateFieldGet(this, _Events_emitter, "f").on("attachmentFile", handler);
    }
    offAll() {
        __classPrivateFieldGet(this, _Events_emitter, "f").removeAllListeners();
        for (const handler of __classPrivateFieldGet(this, _Events_handlers, "f")) {
            handler.ac?.abort();
        }
        __classPrivateFieldSet(this, _Events_handlers, [], "f");
    }
}
_Events_emitter = new WeakMap(), _Events_handlers = new WeakMap(), _Events_instances = new WeakSet(), _Events_createHandler = function _Events_createHandler(maxTimeout, listener) {
    const handler = {
        buffer: [],
    };
    __classPrivateFieldGet(this, _Events_handlers, "f").push(handler);
    return (trId) => {
        handler.buffer.push(trId);
        if (handler.timeout) {
            return;
        }
        handler.ac = new AbortController();
        handler.timeout = setTimeout(maxTimeout, undefined, { signal: handler.ac.signal })
            .then(() => {
            handler.timeout = undefined;
            const bufferCopy = [...handler.buffer];
            handler.buffer = [];
            handler.ac = undefined;
            return listener(bufferCopy);
        })
            .catch((err) => {
            if (err.name === "AbortError") {
                return;
            }
            console.error("can't execute listener", err);
        });
    };
};
