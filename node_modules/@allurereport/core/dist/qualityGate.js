var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _QualityGate_instances, _QualityGate_mappedValidators_get, _QualityGate_createRulesValidator;
import { filterSuccessful, filterUnsuccessful } from "@allurereport/core-api";
export class AbstractQualityGateValidator {
    constructor(limit, meta) {
        this.limit = limit;
        this.meta = meta;
    }
    async getTestResultsFilteredByMeta(store) {
        const allTrs = await store.allTestResults();
        if (!this.meta) {
            return allTrs;
        }
        return allTrs.filter((tr) => {
            switch (this.meta?.type) {
                case "label":
                    return tr.labels.some((label) => label.name === this.meta.name && label.value === this.meta.value);
                case "parameter":
                    return tr.parameters.some((parameter) => parameter.name === this.meta.name && parameter.value === this.meta.value);
                default:
                    return tr;
            }
        });
    }
}
export class MaxFailuresValidator extends AbstractQualityGateValidator {
    async validate(store) {
        const trs = (await this.getTestResultsFilteredByMeta(store)).filter((tr) => !tr.hidden).filter(filterUnsuccessful);
        return {
            success: trs.length <= this.limit,
            rule: "maxFailures",
            meta: this.meta,
            expected: this.limit,
            actual: trs.length,
        };
    }
}
export class MinTestsCountValidator extends AbstractQualityGateValidator {
    async validate(store) {
        const trs = (await this.getTestResultsFilteredByMeta(store)).filter((tr) => !tr.hidden);
        return {
            success: trs.length >= this.limit,
            rule: "minTestsCount",
            meta: this.meta,
            expected: this.limit,
            actual: trs.length,
        };
    }
}
export class SuccessRateValidator extends AbstractQualityGateValidator {
    async validate(store) {
        const knownIssues = await store.allKnownIssues();
        const trs = (await this.getTestResultsFilteredByMeta(store)).filter((tr) => !tr.hidden);
        const knownIssuesHistoryIds = knownIssues.map((ki) => ki.historyId);
        const unknown = trs.filter((tr) => !tr.historyId || !knownIssuesHistoryIds.includes(tr.historyId));
        const passed = unknown.filter(filterSuccessful);
        const rate = passed.length === 0 ? 0 : passed.length / unknown.length;
        return {
            success: rate >= this.limit,
            rule: "successRate",
            meta: this.meta,
            expected: this.limit,
            actual: rate,
        };
    }
}
export class QualityGate {
    constructor(config) {
        _QualityGate_instances.add(this);
        this.config = config;
        this.result = [];
        _QualityGate_createRulesValidator.set(this, (rules, meta) => {
            const validators = [];
            Object.keys(rules).forEach((rule) => {
                const Validator = __classPrivateFieldGet(this, _QualityGate_instances, "a", _QualityGate_mappedValidators_get)[rule];
                if (!Validator) {
                    return;
                }
                const validator = new Validator(rules[rule], meta);
                validators.push(validator);
            });
            return validators;
        });
        this.validate = async (store) => {
            const { rules, enforce = [] } = this.config ?? {};
            const validators = [];
            const result = [];
            if (rules) {
                validators.push(...__classPrivateFieldGet(this, _QualityGate_createRulesValidator, "f").call(this, rules));
            }
            enforce.forEach((enforceConfig) => {
                const { rules: enforceRules, ...meta } = enforceConfig;
                validators.push(...__classPrivateFieldGet(this, _QualityGate_createRulesValidator, "f").call(this, enforceRules, meta));
            });
            for (const validator of validators) {
                result.push(await validator.validate(store));
            }
            this.result = result;
        };
    }
    get exitCode() {
        return this.result.some((res) => !res.success) ? 1 : 0;
    }
}
_QualityGate_createRulesValidator = new WeakMap(), _QualityGate_instances = new WeakSet(), _QualityGate_mappedValidators_get = function _QualityGate_mappedValidators_get() {
    return {
        maxFailures: MaxFailuresValidator,
        minTestsCount: MinTestsCountValidator,
        successRate: SuccessRateValidator,
        ...this.config?.validators,
    };
};
